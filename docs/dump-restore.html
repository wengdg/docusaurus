<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Database Dump-Restore · RADGRAD</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta property="og:title" content="Database Dump-Restore · RADGRAD"/><meta property="og:type" content="website"/><meta property="og:url" content="https://Radgrad.github.io/docusaurus/index.html"/><meta property="og:description" content="RadGrad implements a custom mechanism for database dumping (i.e. outputting the contents of the MongoDB database in a file in JSON format) and restoring a dumped database (i.e. loading the contents of the dump file).  We call this capability database dump-restore."/><meta property="og:image" content="https://Radgrad.github.io/docusaurus/img/docusaurus.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://Radgrad.github.io/docusaurus/img/docusaurus.png"/><link rel="shortcut icon" href="/docusaurus/img/radgrad.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://Radgrad.github.io/blog/atom.xml" title="RADGRAD Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://Radgrad.github.io/blog/feed.xml" title="RADGRAD Blog RSS Feed"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nunito"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/docusaurus/css/main.css"/></head><body class="sideNavVisible doc separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/docusaurus/"><img class="logo" src="/docusaurus/img/radgrad_logo.png" alt="RADGRAD"/><h2 class="headerTitleWithLogo">RADGRAD</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docusaurus/docs/why.html" target="_self">Documentation</a></li><li class=""><a href="/docusaurus/en/team2.html" target="_self">Team</a></li><li class=""><a href="/docusaurus/blog" target="_self">News</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Data Model</span></h2></div><div class="navGroups"><div class="navGroup navGroupActive"><h3>Introduction</h3><ul><li class="navListItem"><a class="navItem" href="/docusaurus/docs/why.html">Why RadGrad?</a></li><li class="navListItem"><a class="navItem" href="/docusaurus/docs/Goals.html">Goals</a></li><li class="navListItem"><a class="navItem" href="/docusaurus/docs/About.html">About this manual</a></li></ul></div><div class="navGroup navGroupActive"><h3>Developer Guide</h3><ul><li class="navListItem"><a class="navItem" href="/docusaurus/docs/Installation.html">Installation</a></li><li class="navListItem"><a class="navItem" href="/docusaurus/docs/IDE.html">IDE Setup</a></li><li class="navListItem"><a class="navItem" href="/docusaurus/docs/source-code-organization.html">Source code organization</a></li><li class="navListItem"><a class="navItem" href="/docusaurus/docs/codingstandards.html">Coding Standards</a></li><li class="navListItem"><a class="navItem" href="/docusaurus/docs/testing.html">Testing</a></li><li class="navListItem"><a class="navItem" href="/docusaurus/docs/database-fixtures.html">Database Fixtures</a></li><li class="navListItem"><a class="navItem" href="/docusaurus/docs/continuous-integration.html">Continuous Integration</a></li></ul></div><div class="navGroup navGroupActive"><h3>Data Model</h3><ul><li class="navListItem"><a class="navItem" href="/docusaurus/docs/overview.html">Overview</a></li><li class="navListItem"><a class="navItem" href="/docusaurus/docs/class-hierarchy.html">Class Hierarchy</a></li><li class="navListItem"><a class="navItem" href="/docusaurus/docs/entity-relationship-model.html">Entity-Relationship Model</a></li><li class="navListItem"><a class="navItem" href="/docusaurus/docs/user-management.html">User Management</a></li><li class="navListItem"><a class="navItem" href="/docusaurus/docs/ice.html">ICE (Innovation, Competency, Experience)</a></li><li class="navListItem navListItemActive"><a class="navItem navItemActive" href="/docusaurus/docs/dump-restore.html">Database Dump-Restore</a></li><li class="navListItem"><a class="navItem" href="/docusaurus/docs/pub-sub.html">Pub-Sub Caching</a></li><li class="navListItem"><a class="navItem" href="/docusaurus/docs/integrity-checking.html">Integrity Checking</a></li></ul></div><div class="navGroup navGroupActive"><h3>API</h3><ul><li class="navListItem"><a class="navItem" href="/docusaurus/docs/javascript-jsdocs.html">Javascript</a></li></ul></div><div class="navGroup navGroupActive"><h3>Documentation</h3><ul><li class="navListItem"><a class="navItem" href="/docusaurus/docs/docusaurus.html">Docusaurus</a></li><li class="navListItem"><a class="navItem" href="/docusaurus/docs/jsdoc.html">JSDoc</a></li></ul></div><div class="navGroup navGroupActive"><h3>Delivery</h3><ul><li class="navListItem"><a class="navItem" href="/docusaurus/docs/scripts.html">Development scripts</a></li><li class="navListItem"><a class="navItem" href="/docusaurus/docs/deployment.html">Deployment</a></li><li class="navListItem"><a class="navItem" href="/docusaurus/docs/cas.html">CAS Authentication</a></li><li class="navListItem"><a class="navItem" href="/docusaurus/docs/cloudinary.html">Cloudinary Image Service</a></li><li class="navListItem"><a class="navItem" href="/docusaurus/docs/star-bulk-download.html">Importing bulk STAR data</a></li><li class="navListItem"><a class="navItem" href="/docusaurus/docs/level-calculation.html">Level Calculation</a></li></ul></div><div class="navGroup navGroupActive"><h3>Onboard Analytics</h3><ul><li class="navListItem"><a class="navItem" href="/docusaurus/docs/analytics-overview.html">Overview</a></li></ul></div><div class="navGroup navGroupActive"><h3>Archive</h3><ul><li class="navListItem"><a class="navItem" href="/docusaurus/docs/use-cases.html">Use Cases (Fall 2016)</a></li><li class="navListItem"><a class="navItem" href="/docusaurus/docs/beta-test.html">Beta Test (Spring 2017)</a></li><li class="navListItem"><a class="navItem" href="/docusaurus/docs/radgrad-registration.html">RadGrad Registration</a></li></ul></div></div></section></div><script>
          var toggler = document.getElementById('navToggler');
          var nav = document.getElementById('docsNav');
          toggler.onclick = function() {
            nav.classList.toggle('docsSliderActive');
          };
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1>Database Dump-Restore</h1></header><article><div><span><p>RadGrad implements a custom mechanism for database dumping (i.e. outputting the contents of the MongoDB database in a file in JSON format) and restoring a dumped database (i.e. loading the contents of the dump file).  We call this capability database dump-restore.</p>
<p>We are aware that MongoDB provides a built-in facility through <a href="https://docs.mongodb.com/manual/tutorial/backup-and-restore-tools/">MongoDB Tools</a> to dump the contents of a MongoDB database in a manner that allows reloading. We chose to develop our own custom method because we wanted a way to define database fixture files in a human-readable form, and because we were worried about database integrity problems with MongoDB as our schemas evolved and so we wanted a way to easily edit database fixture files to repair integrity violations by hand if they happened to occur.</p>
<h2><a class="anchor" aria-hidden="true" id="dump"></a><a href="#dump" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dump</h2>
<p>As noted previously, in RadGrad, all collections are managed through a set of Javascript classes.  The classes that wrap each collection inherit from the class BaseCollection, which defines a method called <code>dumpOne()</code> whose default implementation throws an error:</p>
<pre><code class="hljs css js"> <span class="hljs-comment">/**
   * Returns an object representing the definition of docID in a format appropriate to the restoreOne function.
   * Must be overridden by each collection.
   * @param docID A docID from this collection.
   * @returns { Object } An object representing this document.
   */</span>
  dumpOne(docID) { <span class="hljs-comment">// eslint-disable-line</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Meteor.Error(<span class="hljs-string">`Default dumpOne method invoked by collection <span class="hljs-subst">${<span class="hljs-keyword">this</span>._collectionName}</span>`</span>);
  }
</code></pre>
<p>Each collection class must define a dumpOne method, which is generates an object representing the docID that it was passed. For example, here is the <code>dumpOne()</code> method for the CareerGoal collection:</p>
<pre><code class="hljs css js"> <span class="hljs-comment">/**
   * Returns an object representing the CareerGoal docID in a format acceptable to define().
   * @param docID The docID of a CareerGoal.
   * @returns { Object } An object representing the definition of docID.
   */</span>
  dumpOne(docID) {
    <span class="hljs-keyword">const</span> doc = <span class="hljs-keyword">this</span>.findDoc(docID);
    <span class="hljs-keyword">const</span> name = doc.name;
    <span class="hljs-keyword">const</span> slug = Slugs.getNameFromID(doc.slugID);
    <span class="hljs-keyword">const</span> description = doc.description;
    <span class="hljs-keyword">const</span> interests = _.map(doc.interestIDs, interestID =&gt; Interests.findSlugByID(interestID));
    <span class="hljs-keyword">return</span> { name, slug, interests, description };
  }
</code></pre>
<p>You can see that this method returns an object with four fields: name, slug, interests, and description. Name, slug, and description are Strings, and Interests is an array of Strings (the Slugs corresponding to the InterestIDs in the document).</p>
<p>Now the question is, why is that the appropriate object to return from dumpOne?  To understand the answer, you need to also know that each Javascript class also defines a method called <code>define()</code> which accepts an object containing fields representing the initial values for a document in the underlying MongoDB collection. This is the standard way in RadGrad to create MongoDB documents in the data model.  Here, for example, is the define() method for the CareerGoal collection:</p>
<pre><code class="hljs css js"> <span class="hljs-comment">/**
   * Defines a new CareerGoal with its name, slug, and description.
   * @example
   * CareerGoals.define({ name: 'Database Administrator',
   *                      slug: 'database-administrator',
   *                      description: 'Wrangler of SQL.',
   *                      interests: ['application-development', 'software-engineering', 'databases'],
   *                    });
   * @param { Object } description Object with keys name, slug, description, interests.
   * Slug must be globally unique and previously undefined.
   * Interests is a (possibly empty) array of defined interest slugs or interestIDs.
   * Syllabus is optional. If supplied, should be a URL.
   * @throws { Meteor.Error } If the slug already exists.
   * @returns The newly created docID.
   */</span>
  define({ name, slug, description, interests }) {
    <span class="hljs-comment">// Get Interests, throw error if any of them are not found.</span>
    <span class="hljs-keyword">const</span> interestIDs = Interests.getIDs(interests);
    <span class="hljs-comment">// Get SlugID, throw error if found.</span>
    <span class="hljs-keyword">const</span> slugID = Slugs.define({ <span class="hljs-attr">name</span>: slug, <span class="hljs-attr">entityName</span>: <span class="hljs-keyword">this</span>.getType() });
    <span class="hljs-keyword">const</span> docID = <span class="hljs-keyword">this</span>._collection.insert({ name, slugID, description, interestIDs });
    <span class="hljs-comment">// Connect the Slug to this Interest</span>
    Slugs.updateEntityID(slugID, docID);
    <span class="hljs-keyword">return</span> docID;
  }
</code></pre>
<p>It's not necessary to understand the implementation of this define() method at this point: what is important to see is that the object returned by the dumpOne() method of the CareerGoalCollection class is in precisely the correct format required by the define() method of that same class in order to create a new CareerGoal document.</p>
<p>This relationship between <code>dumpOne()</code> and <code>define()</code> is the central idea behind RadGrad's dump mechanism. There is more code to implement the mechanics of dumping:  iterating through each docID in each collection,writing out the results as a json file, determining where to write the file, and so forth. But if you understand and can adhere to this relationship between <code>dumpOne</code> and <code>define()</code>, then you can create new classes and manage other ones successfully.</p>
<p>Note that whenever a change is made the parameters to a <code>define()</code> method, you must make sure to update the <code>dumpOne()</code> method as well!</p>
<h2><a class="anchor" aria-hidden="true" id="restore"></a><a href="#restore" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Restore</h2>
<p>&quot;Restore&quot; refers to the process of initializing the MongoDB database from scratch with the contents of a file created through the &quot;Dump&quot; mechanism.</p>
<p>The  process of database restoration involves the following sequence:</p>
<p>First, the developer specifies a field called &quot;databaseRestoreFileName&quot; in the JSON settings file passed to Meteor. For example:</p>
<pre><code class="hljs css js"><span class="hljs-string">"databaseRestoreFileName"</span>: <span class="hljs-string">"database/snapshot/2017-08-02-14-12-04.json"</span>,
</code></pre>
<p>The value of this field is a path within the <code>private</code> directory of the RadGrad application. Here's <a href="https://github.com/radgrad/radgrad/blob/master/app/private/database/snapshot/2017-08-02-14-12-04.json">2017-08-14-12-04.json</a>.</p>
<p>If and only if the database is empty when the system comes up, then the contents of this file will be used to initialize the database.    See the loadDatabase() function in <a href="https://github.com/radgrad/radgrad/blob/master/app/imports/startup/server/initialize-db.js">initialize-db.js</a> to see the process.</p>
<p>To ensure that the database being loaded is consistent with the system's data model, the loading process requires that two constraints are met:</p>
<ol>
<li>The set of collections expected in the RadGrad application are all present in the database json file.</li>
<li>There are no collections present in the database json file that are not expected by the application.</li>
</ol>
<p>In other words, the database json file contains exactly the set of collections required by RadGrad.</p>
<p>There are other ways the loading process can fail.  As noted elsewhere, entities in the data model can link to each other. For example, a StudentProfile instance can contain a list of docIDs of the Interests associated with the student.  There can be no forward referencing in RadGrad, so any Interest associated with a StudentProfile must be defined prior to defining the profile instance.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="ice.html">← ICE (Innovation, Competency, Experience)</a><a class="docs-next button" href="pub-sub.html">Pub-Sub Caching →</a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#dump">Dump</a></li><li><a href="#restore">Restore</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/docusaurus/" class="nav-home"><img src="/docusaurus/img/radgrad_logo.png" alt="RADGRAD" width="66" height="58"/></a><div><h5>Growing awesome computer scientists, one graduate at a time</h5></div><div><h5>Community</h5><a href="http://radgrad.org/">RadGrad.org</a></div><div><h5>Repositories</h5><a href="https://github.com/radgrad" target="_blank" rel="noreferrer noopener">GitHub</a></div></section><section class="copyright">Copyright © 2018 RadGrad</section></footer></div></body></html>